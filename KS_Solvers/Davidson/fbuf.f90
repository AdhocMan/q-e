! This file is part of FBUF - Fortran BUFfers For Accelerators
! Copyright 2018 Pietro Bonfa'
! License: GPL

!!!!! DO NOT EDIT THIS FILE, IT'S AUTOGENERATED !!!!!

!> The **FBUF** module.

module fbuf
#ifdef __CUDA
  use cudafor
  implicit none
  integer, parameter :: DP = selected_real_kind(14,200)
  !
  type ivb_t
    integer, device, pointer  :: data_d(:)
    integer :: dsize
    logical :: locked
  end type ivb_t
  
  type imb_t
    integer, device, pointer  :: data_d(:,:)
    integer :: dsize(2)
    logical :: locked
  end type imb_t
  
  type itb_t
    integer, device, pointer  :: data_d(:,:,:)
    integer :: dsize(3)
    logical :: locked
  end type itb_t
  
  type rvb_t
    real(DP), device, pointer  :: data_d(:)
    integer :: dsize
    logical :: locked
  end type rvb_t
  
  type rmb_t
    real(DP), device, pointer  :: data_d(:,:)
    integer :: dsize(2)
    logical :: locked
  end type rmb_t
  
  type rtb_t
    real(DP), device, pointer  :: data_d(:,:,:)
    integer :: dsize(3)
    logical :: locked
  end type rtb_t
  
  type cvb_t
    complex(DP), device, pointer  :: data_d(:)
    integer :: dsize
    logical :: locked
  end type cvb_t
  
  type cmb_t
    complex(DP), device, pointer  :: data_d(:,:)
    integer :: dsize(2)
    logical :: locked
  end type cmb_t
  
  type ctb_t
    complex(DP), device, pointer  :: data_d(:,:,:)
    integer :: dsize(3)
    logical :: locked
  end type ctb_t
  

  private
  public :: buf_t


!> The main **fbuf** class.
  type :: buf_t
     logical :: is_initialized = .false.             !< Logical, tells if initialization has been done
     integer :: nbufs
     logical :: verbose
     type(ivb_t), allocatable, dimension(:) :: ivb

     type(imb_t), allocatable, dimension(:) :: imb

     type(itb_t), allocatable, dimension(:) :: itb

     type(rvb_t), allocatable, dimension(:) :: rvb

     type(rmb_t), allocatable, dimension(:) :: rmb

     type(rtb_t), allocatable, dimension(:) :: rtb

     type(cvb_t), allocatable, dimension(:) :: cvb

     type(cmb_t), allocatable, dimension(:) :: cmb

     type(ctb_t), allocatable, dimension(:) :: ctb

     !
   contains
     procedure :: init                     !< Initialize the class selecting buffers dimension and number per type.\
     final :: clean

     generic, public :: lock_buffer => &
                        lock_buffer_iv, &           !< Releases a integer, device vector buffer
                        lock_buffer_im, &           !< Releases a integer, device matrix buffer
                        lock_buffer_it, &           !< Releases a integer, device tensor buffer
                        lock_buffer_rv, &           !< Releases a real(DP), device vector buffer
                        lock_buffer_rm, &           !< Releases a real(DP), device matrix buffer
                        lock_buffer_rt, &           !< Releases a real(DP), device tensor buffer
                        lock_buffer_cv, &           !< Releases a complex(DP), device vector buffer
                        lock_buffer_cm, &           !< Releases a complex(DP), device matrix buffer
                        lock_buffer_ct           !< Releases a complex(DP), device tensor buffer
     !     
     procedure, private :: lock_buffer_iv           !< Releases a integer, device vector buffer     
     procedure, private :: lock_buffer_im           !< Releases a integer, device matrix buffer     
     procedure, private :: lock_buffer_it           !< Releases a integer, device tensor buffer     
     procedure, private :: lock_buffer_rv           !< Releases a real(DP), device vector buffer     
     procedure, private :: lock_buffer_rm           !< Releases a real(DP), device matrix buffer     
     procedure, private :: lock_buffer_rt           !< Releases a real(DP), device tensor buffer     
     procedure, private :: lock_buffer_cv           !< Releases a complex(DP), device vector buffer     
     procedure, private :: lock_buffer_cm           !< Releases a complex(DP), device matrix buffer     
     procedure, private :: lock_buffer_ct           !< Releases a complex(DP), device tensor buffer
     !
     generic, public :: release_buffer => &
                        release_buffer_iv, &        !< Releases a integer, device vector buffer
                        release_buffer_im, &        !< Releases a integer, device matrix buffer
                        release_buffer_it, &        !< Releases a integer, device tensor buffer
                        release_buffer_rv, &        !< Releases a real(DP), device vector buffer
                        release_buffer_rm, &        !< Releases a real(DP), device matrix buffer
                        release_buffer_rt, &        !< Releases a real(DP), device tensor buffer
                        release_buffer_cv, &        !< Releases a complex(DP), device vector buffer
                        release_buffer_cm, &        !< Releases a complex(DP), device matrix buffer
                        release_buffer_ct        !< Releases a complex(DP), device tensor buffer
     !     
     procedure, private :: release_buffer_iv           !< Releases a integer, device vector buffer     
     procedure, private :: release_buffer_im           !< Releases a integer, device matrix buffer     
     procedure, private :: release_buffer_it           !< Releases a integer, device tensor buffer     
     procedure, private :: release_buffer_rv           !< Releases a real(DP), device vector buffer     
     procedure, private :: release_buffer_rm           !< Releases a real(DP), device matrix buffer     
     procedure, private :: release_buffer_rt           !< Releases a real(DP), device tensor buffer     
     procedure, private :: release_buffer_cv           !< Releases a complex(DP), device vector buffer     
     procedure, private :: release_buffer_cm           !< Releases a complex(DP), device matrix buffer     
     procedure, private :: release_buffer_ct           !< Releases a complex(DP), device tensor buffer
  end type

  
  
contains
  !> Initialize the class selecting the device type.
  subroutine init(this, n, info, verbose)
    implicit none
    class(buf_t),  intent(inout) :: this     !< The class.
    integer,       intent(in)  :: n       !< Wether device can be the host itself
    integer,       intent(out) :: info    !< Error reporting.
                                          !<  0: ok
                                          !< -1: generic error
    logical, optional, intent(in) :: verbose
    !
    integer :: i
    this%is_initialized = .true.
    this%nbufs = n
    this%verbose = .false.
    if (present(verbose)) this%verbose = verbose
    
    if (this%verbose) write (*, *) "Initializing ", this%nbufs, " buffers"
    
    allocate(this%ivb(n), this%imb(n), this%itb(n), this%rvb(n), this%rmb(n), this%rtb(n), this%cvb(n), this%cmb(n), this%ctb(n))
    do i=1,n
      this%ivb(i)%locked = .false.
      this%imb(i)%locked = .false.
      this%itb(i)%locked = .false.
      this%rvb(i)%locked = .false.
      this%rmb(i)%locked = .false.
      this%rtb(i)%locked = .false.
      this%cvb(i)%locked = .false.
      this%cmb(i)%locked = .false.
      this%ctb(i)%locked = .false.
      !
      this%ivb(i)%dsize = -1
      this%imb(i)%dsize = -1
      this%itb(i)%dsize = -1
      this%rvb(i)%dsize = -1
      this%rmb(i)%dsize = -1
      this%rtb(i)%dsize = -1
      this%cvb(i)%dsize = -1
      this%cmb(i)%dsize = -1
      this%ctb(i)%dsize = -1
      !
      this%ivb(i)%data_d => NULL()
      this%imb(i)%data_d => NULL()
      this%itb(i)%data_d => NULL()
      this%rvb(i)%data_d => NULL()
      this%rmb(i)%data_d => NULL()
      this%rtb(i)%data_d => NULL()
      this%cvb(i)%data_d => NULL()
      this%cmb(i)%data_d => NULL()
      this%ctb(i)%data_d => NULL()
      !
    end do
    info = 0
    !
  end subroutine init
  subroutine clean(this)
    implicit none
    type(buf_t) :: this     !< The class.
    integer :: i
    if (this%verbose) write (*, '("Cleaning ", I2, " buffers")') this%nbufs


    do i=1,this%nbufs
      if (this%ivb(i)%dsize > 0) deallocate(this%ivb(i)%data_d)
    end do
    deallocate(this%ivb)

    do i=1,this%nbufs
      if (ALL(this%imb(i)%dsize > 0)) deallocate(this%imb(i)%data_d)
    end do
    deallocate(this%imb)

    do i=1,this%nbufs
      if (ALL(this%itb(i)%dsize > 0)) deallocate(this%itb(i)%data_d)
    end do
    deallocate(this%itb)

    do i=1,this%nbufs
      if (this%rvb(i)%dsize > 0) deallocate(this%rvb(i)%data_d)
    end do
    deallocate(this%rvb)

    do i=1,this%nbufs
      if (ALL(this%rmb(i)%dsize > 0)) deallocate(this%rmb(i)%data_d)
    end do
    deallocate(this%rmb)

    do i=1,this%nbufs
      if (ALL(this%rtb(i)%dsize > 0)) deallocate(this%rtb(i)%data_d)
    end do
    deallocate(this%rtb)

    do i=1,this%nbufs
      if (this%cvb(i)%dsize > 0) deallocate(this%cvb(i)%data_d)
    end do
    deallocate(this%cvb)

    do i=1,this%nbufs
      if (ALL(this%cmb(i)%dsize > 0)) deallocate(this%cmb(i)%data_d)
    end do
    deallocate(this%cmb)

    do i=1,this%nbufs
      if (ALL(this%ctb(i)%dsize > 0)) deallocate(this%ctb(i)%data_d)
    end do
    deallocate(this%ctb)

    
    this%is_initialized = .false.
  end subroutine clean
  !

  !> Get or allocate a buffer for an integer, device vector.
  subroutine lock_buffer_iv(this, p, vsize, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    integer, device, pointer, intent(out) :: p(:)   !< Pointer possibly set to access buffer
    integer,       intent(in) :: vsize    !< vector dimension
    integer,       intent(out) :: info    !<  0: ok
                                          !< -1: no buffers left, allocating space
                                          !< -2: unexpected error, no memory left
                                          !< other values come form allocate stat
    integer :: i
    ! add omp critical here
    if (this%verbose) write(*,100) vsize
    info = 0
    ! the logic here is the following:
    !  we loop until a free (.i.e. not locked) buffer is found
    do i=1,this%nbufs
      !
      if (this%ivb(i)%locked) cycle
      ! if this point is reached, a free has been found
      !  check if it's large enough.
      if ( this%ivb(i)%dsize >= vsize ) then
        this%ivb(i)%locked = .true.
        p => this%ivb(i)%data_d
        if (this%verbose) write(*,101) i , this%ivb(i)%dsize
        return
      else if ( this%ivb(i)%dsize > 0 ) then
        if (this%verbose) write(*, 102) i, this%ivb(i)%dsize
        deallocate(this%ivb(i)%data_d)
        allocate(this%ivb(i)%data_d(vsize), stat=info)
        if (info /= 0) return
        this%ivb(i)%dsize = vsize
        this%ivb(i)%locked = .true.
        p => this%ivb(i)%data_d
        return
      else
        ! the buffer was never initialized
        allocate(this%ivb(i)%data_d(vsize), stat=info)
        if (info /= 0) return
        this%ivb(i)%dsize = vsize
        this%ivb(i)%locked = .true.
        p => this%ivb(i)%data_d
        if (this%verbose) write(*, 103) i
        return  
      end if
      exit
    end do
    if (this%verbose) write(*, 104) 
    allocate(p(vsize))
    info = -1
    !
    100 FORMAT ("Locking a buffer for an integer, device vector ", 1I4, " elements long")
    101 FORMAT ("Buffer ", I2 , " is free and ", 1I4, " elements long. Locked.")
    102 FORMAT ("Buffer ", I2 , " is free but ", 1I4, " elements long. Reallocating and Locking.")
    103 FORMAT ("Buffer ", I2 , " is free but not allocated. Allocated and Locked.")
    104 FORMAT ("No free buffers found. Allocated space outside buffers.")
  end subroutine lock_buffer_iv

  !> Get or allocate a buffer for an integer, device matrix.
  subroutine lock_buffer_im(this, p, msize, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    integer, device, pointer, intent(out) :: p(:,:)   !< Pointer possibly set to access buffer
    integer,       intent(in) :: msize(2)    !< matrix dimension
    integer,       intent(out) :: info    !<  0: ok
                                          !< -1: no buffers left, allocating space
                                          !< -2: unexpected error, no memory left
                                          !< other values come form allocate stat
    integer :: i
    ! add omp critical here
    if (this%verbose) write(*,100) msize
    info = 0
    ! the logic here is the following:
    !  we loop until a free (.i.e. not locked) buffer is found
    do i=1,this%nbufs
      !
      if (this%imb(i)%locked) cycle
      ! if this point is reached, a free has been found
      !  check if it's large enough.
      if (ALL( this%imb(i)%dsize >= msize )) then
        this%imb(i)%locked = .true.
        p => this%imb(i)%data_d
        if (this%verbose) write(*,101) i , this%imb(i)%dsize
        return
      else if (ALL( this%imb(i)%dsize > 0 )) then
        if (this%verbose) write(*, 102) i, this%imb(i)%dsize
        deallocate(this%imb(i)%data_d)
        allocate(this%imb(i)%data_d(msize(1),msize(2)), stat=info)
        if (info /= 0) return
        this%imb(i)%dsize = msize
        this%imb(i)%locked = .true.
        p => this%imb(i)%data_d
        return
      else
        ! the buffer was never initialized
        allocate(this%imb(i)%data_d(msize(1),msize(2)), stat=info)
        if (info /= 0) return
        this%imb(i)%dsize = msize
        this%imb(i)%locked = .true.
        p => this%imb(i)%data_d
        if (this%verbose) write(*, 103) i
        return  
      end if
      exit
    end do
    if (this%verbose) write(*, 104) 
    allocate(p(msize(1),msize(2)))
    info = -1
    !
    100 FORMAT ("Locking a buffer for an integer, device matrix ", 2I4, " elements long")
    101 FORMAT ("Buffer ", I2 , " is free and ", 2I4, " elements long. Locked.")
    102 FORMAT ("Buffer ", I2 , " is free but ", 2I4, " elements long. Reallocating and Locking.")
    103 FORMAT ("Buffer ", I2 , " is free but not allocated. Allocated and Locked.")
    104 FORMAT ("No free buffers found. Allocated space outside buffers.")
  end subroutine lock_buffer_im

  !> Get or allocate a buffer for an integer, device tensor.
  subroutine lock_buffer_it(this, p, tsize, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    integer, device, pointer, intent(out) :: p(:,:,:)   !< Pointer possibly set to access buffer
    integer,       intent(in) :: tsize(3)    !< tensor dimension
    integer,       intent(out) :: info    !<  0: ok
                                          !< -1: no buffers left, allocating space
                                          !< -2: unexpected error, no memory left
                                          !< other values come form allocate stat
    integer :: i
    ! add omp critical here
    if (this%verbose) write(*,100) tsize
    info = 0
    ! the logic here is the following:
    !  we loop until a free (.i.e. not locked) buffer is found
    do i=1,this%nbufs
      !
      if (this%itb(i)%locked) cycle
      ! if this point is reached, a free has been found
      !  check if it's large enough.
      if (ALL( this%itb(i)%dsize >= tsize )) then
        this%itb(i)%locked = .true.
        p => this%itb(i)%data_d
        if (this%verbose) write(*,101) i , this%itb(i)%dsize
        return
      else if (ALL( this%itb(i)%dsize > 0 )) then
        if (this%verbose) write(*, 102) i, this%itb(i)%dsize
        deallocate(this%itb(i)%data_d)
        allocate(this%itb(i)%data_d(tsize(1),tsize(2),tsize(3)), stat=info)
        if (info /= 0) return
        this%itb(i)%dsize = tsize
        this%itb(i)%locked = .true.
        p => this%itb(i)%data_d
        return
      else
        ! the buffer was never initialized
        allocate(this%itb(i)%data_d(tsize(1),tsize(2),tsize(3)), stat=info)
        if (info /= 0) return
        this%itb(i)%dsize = tsize
        this%itb(i)%locked = .true.
        p => this%itb(i)%data_d
        if (this%verbose) write(*, 103) i
        return  
      end if
      exit
    end do
    if (this%verbose) write(*, 104) 
    allocate(p(tsize(1),tsize(2),tsize(3)))
    info = -1
    !
    100 FORMAT ("Locking a buffer for an integer, device tensor ", 3I4, " elements long")
    101 FORMAT ("Buffer ", I2 , " is free and ", 3I4, " elements long. Locked.")
    102 FORMAT ("Buffer ", I2 , " is free but ", 3I4, " elements long. Reallocating and Locking.")
    103 FORMAT ("Buffer ", I2 , " is free but not allocated. Allocated and Locked.")
    104 FORMAT ("No free buffers found. Allocated space outside buffers.")
  end subroutine lock_buffer_it

  !> Get or allocate a buffer for an real(DP), device vector.
  subroutine lock_buffer_rv(this, p, vsize, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    real(DP), device, pointer, intent(out) :: p(:)   !< Pointer possibly set to access buffer
    integer,       intent(in) :: vsize    !< vector dimension
    integer,       intent(out) :: info    !<  0: ok
                                          !< -1: no buffers left, allocating space
                                          !< -2: unexpected error, no memory left
                                          !< other values come form allocate stat
    integer :: i
    ! add omp critical here
    if (this%verbose) write(*,100) vsize
    info = 0
    ! the logic here is the following:
    !  we loop until a free (.i.e. not locked) buffer is found
    do i=1,this%nbufs
      !
      if (this%rvb(i)%locked) cycle
      ! if this point is reached, a free has been found
      !  check if it's large enough.
      if ( this%rvb(i)%dsize >= vsize ) then
        this%rvb(i)%locked = .true.
        p => this%rvb(i)%data_d
        if (this%verbose) write(*,101) i , this%rvb(i)%dsize
        return
      else if ( this%rvb(i)%dsize > 0 ) then
        if (this%verbose) write(*, 102) i, this%rvb(i)%dsize
        deallocate(this%rvb(i)%data_d)
        allocate(this%rvb(i)%data_d(vsize), stat=info)
        if (info /= 0) return
        this%rvb(i)%dsize = vsize
        this%rvb(i)%locked = .true.
        p => this%rvb(i)%data_d
        return
      else
        ! the buffer was never initialized
        allocate(this%rvb(i)%data_d(vsize), stat=info)
        if (info /= 0) return
        this%rvb(i)%dsize = vsize
        this%rvb(i)%locked = .true.
        p => this%rvb(i)%data_d
        if (this%verbose) write(*, 103) i
        return  
      end if
      exit
    end do
    if (this%verbose) write(*, 104) 
    allocate(p(vsize))
    info = -1
    !
    100 FORMAT ("Locking a buffer for an real(DP), device vector ", 1I4, " elements long")
    101 FORMAT ("Buffer ", I2 , " is free and ", 1I4, " elements long. Locked.")
    102 FORMAT ("Buffer ", I2 , " is free but ", 1I4, " elements long. Reallocating and Locking.")
    103 FORMAT ("Buffer ", I2 , " is free but not allocated. Allocated and Locked.")
    104 FORMAT ("No free buffers found. Allocated space outside buffers.")
  end subroutine lock_buffer_rv

  !> Get or allocate a buffer for an real(DP), device matrix.
  subroutine lock_buffer_rm(this, p, msize, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    real(DP), device, pointer, intent(out) :: p(:,:)   !< Pointer possibly set to access buffer
    integer,       intent(in) :: msize(2)    !< matrix dimension
    integer,       intent(out) :: info    !<  0: ok
                                          !< -1: no buffers left, allocating space
                                          !< -2: unexpected error, no memory left
                                          !< other values come form allocate stat
    integer :: i
    ! add omp critical here
    if (this%verbose) write(*,100) msize
    info = 0
    ! the logic here is the following:
    !  we loop until a free (.i.e. not locked) buffer is found
    do i=1,this%nbufs
      !
      if (this%rmb(i)%locked) cycle
      ! if this point is reached, a free has been found
      !  check if it's large enough.
      if (ALL( this%rmb(i)%dsize >= msize )) then
        this%rmb(i)%locked = .true.
        p => this%rmb(i)%data_d
        if (this%verbose) write(*,101) i , this%rmb(i)%dsize
        return
      else if (ALL( this%rmb(i)%dsize > 0 )) then
        if (this%verbose) write(*, 102) i, this%rmb(i)%dsize
        deallocate(this%rmb(i)%data_d)
        allocate(this%rmb(i)%data_d(msize(1),msize(2)), stat=info)
        if (info /= 0) return
        this%rmb(i)%dsize = msize
        this%rmb(i)%locked = .true.
        p => this%rmb(i)%data_d
        return
      else
        ! the buffer was never initialized
        allocate(this%rmb(i)%data_d(msize(1),msize(2)), stat=info)
        if (info /= 0) return
        this%rmb(i)%dsize = msize
        this%rmb(i)%locked = .true.
        p => this%rmb(i)%data_d
        if (this%verbose) write(*, 103) i
        return  
      end if
      exit
    end do
    if (this%verbose) write(*, 104) 
    allocate(p(msize(1),msize(2)))
    info = -1
    !
    100 FORMAT ("Locking a buffer for an real(DP), device matrix ", 2I4, " elements long")
    101 FORMAT ("Buffer ", I2 , " is free and ", 2I4, " elements long. Locked.")
    102 FORMAT ("Buffer ", I2 , " is free but ", 2I4, " elements long. Reallocating and Locking.")
    103 FORMAT ("Buffer ", I2 , " is free but not allocated. Allocated and Locked.")
    104 FORMAT ("No free buffers found. Allocated space outside buffers.")
  end subroutine lock_buffer_rm

  !> Get or allocate a buffer for an real(DP), device tensor.
  subroutine lock_buffer_rt(this, p, tsize, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    real(DP), device, pointer, intent(out) :: p(:,:,:)   !< Pointer possibly set to access buffer
    integer,       intent(in) :: tsize(3)    !< tensor dimension
    integer,       intent(out) :: info    !<  0: ok
                                          !< -1: no buffers left, allocating space
                                          !< -2: unexpected error, no memory left
                                          !< other values come form allocate stat
    integer :: i
    ! add omp critical here
    if (this%verbose) write(*,100) tsize
    info = 0
    ! the logic here is the following:
    !  we loop until a free (.i.e. not locked) buffer is found
    do i=1,this%nbufs
      !
      if (this%rtb(i)%locked) cycle
      ! if this point is reached, a free has been found
      !  check if it's large enough.
      if (ALL( this%rtb(i)%dsize >= tsize )) then
        this%rtb(i)%locked = .true.
        p => this%rtb(i)%data_d
        if (this%verbose) write(*,101) i , this%rtb(i)%dsize
        return
      else if (ALL( this%rtb(i)%dsize > 0 )) then
        if (this%verbose) write(*, 102) i, this%rtb(i)%dsize
        deallocate(this%rtb(i)%data_d)
        allocate(this%rtb(i)%data_d(tsize(1),tsize(2),tsize(3)), stat=info)
        if (info /= 0) return
        this%rtb(i)%dsize = tsize
        this%rtb(i)%locked = .true.
        p => this%rtb(i)%data_d
        return
      else
        ! the buffer was never initialized
        allocate(this%rtb(i)%data_d(tsize(1),tsize(2),tsize(3)), stat=info)
        if (info /= 0) return
        this%rtb(i)%dsize = tsize
        this%rtb(i)%locked = .true.
        p => this%rtb(i)%data_d
        if (this%verbose) write(*, 103) i
        return  
      end if
      exit
    end do
    if (this%verbose) write(*, 104) 
    allocate(p(tsize(1),tsize(2),tsize(3)))
    info = -1
    !
    100 FORMAT ("Locking a buffer for an real(DP), device tensor ", 3I4, " elements long")
    101 FORMAT ("Buffer ", I2 , " is free and ", 3I4, " elements long. Locked.")
    102 FORMAT ("Buffer ", I2 , " is free but ", 3I4, " elements long. Reallocating and Locking.")
    103 FORMAT ("Buffer ", I2 , " is free but not allocated. Allocated and Locked.")
    104 FORMAT ("No free buffers found. Allocated space outside buffers.")
  end subroutine lock_buffer_rt

  !> Get or allocate a buffer for an complex(DP), device vector.
  subroutine lock_buffer_cv(this, p, vsize, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    complex(DP), device, pointer, intent(out) :: p(:)   !< Pointer possibly set to access buffer
    integer,       intent(in) :: vsize    !< vector dimension
    integer,       intent(out) :: info    !<  0: ok
                                          !< -1: no buffers left, allocating space
                                          !< -2: unexpected error, no memory left
                                          !< other values come form allocate stat
    integer :: i
    ! add omp critical here
    if (this%verbose) write(*,100) vsize
    info = 0
    ! the logic here is the following:
    !  we loop until a free (.i.e. not locked) buffer is found
    do i=1,this%nbufs
      !
      if (this%cvb(i)%locked) cycle
      ! if this point is reached, a free has been found
      !  check if it's large enough.
      if ( this%cvb(i)%dsize >= vsize ) then
        this%cvb(i)%locked = .true.
        p => this%cvb(i)%data_d
        if (this%verbose) write(*,101) i , this%cvb(i)%dsize
        return
      else if ( this%cvb(i)%dsize > 0 ) then
        if (this%verbose) write(*, 102) i, this%cvb(i)%dsize
        deallocate(this%cvb(i)%data_d)
        allocate(this%cvb(i)%data_d(vsize), stat=info)
        if (info /= 0) return
        this%cvb(i)%dsize = vsize
        this%cvb(i)%locked = .true.
        p => this%cvb(i)%data_d
        return
      else
        ! the buffer was never initialized
        allocate(this%cvb(i)%data_d(vsize), stat=info)
        if (info /= 0) return
        this%cvb(i)%dsize = vsize
        this%cvb(i)%locked = .true.
        p => this%cvb(i)%data_d
        if (this%verbose) write(*, 103) i
        return  
      end if
      exit
    end do
    if (this%verbose) write(*, 104) 
    allocate(p(vsize))
    info = -1
    !
    100 FORMAT ("Locking a buffer for an complex(DP), device vector ", 1I4, " elements long")
    101 FORMAT ("Buffer ", I2 , " is free and ", 1I4, " elements long. Locked.")
    102 FORMAT ("Buffer ", I2 , " is free but ", 1I4, " elements long. Reallocating and Locking.")
    103 FORMAT ("Buffer ", I2 , " is free but not allocated. Allocated and Locked.")
    104 FORMAT ("No free buffers found. Allocated space outside buffers.")
  end subroutine lock_buffer_cv

  !> Get or allocate a buffer for an complex(DP), device matrix.
  subroutine lock_buffer_cm(this, p, msize, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    complex(DP), device, pointer, intent(out) :: p(:,:)   !< Pointer possibly set to access buffer
    integer,       intent(in) :: msize(2)    !< matrix dimension
    integer,       intent(out) :: info    !<  0: ok
                                          !< -1: no buffers left, allocating space
                                          !< -2: unexpected error, no memory left
                                          !< other values come form allocate stat
    integer :: i
    ! add omp critical here
    if (this%verbose) write(*,100) msize
    info = 0
    ! the logic here is the following:
    !  we loop until a free (.i.e. not locked) buffer is found
    do i=1,this%nbufs
      !
      if (this%cmb(i)%locked) cycle
      ! if this point is reached, a free has been found
      !  check if it's large enough.
      if (ALL( this%cmb(i)%dsize >= msize )) then
        this%cmb(i)%locked = .true.
        p => this%cmb(i)%data_d
        if (this%verbose) write(*,101) i , this%cmb(i)%dsize
        return
      else if (ALL( this%cmb(i)%dsize > 0 )) then
        if (this%verbose) write(*, 102) i, this%cmb(i)%dsize
        deallocate(this%cmb(i)%data_d)
        allocate(this%cmb(i)%data_d(msize(1),msize(2)), stat=info)
        if (info /= 0) return
        this%cmb(i)%dsize = msize
        this%cmb(i)%locked = .true.
        p => this%cmb(i)%data_d
        return
      else
        ! the buffer was never initialized
        allocate(this%cmb(i)%data_d(msize(1),msize(2)), stat=info)
        if (info /= 0) return
        this%cmb(i)%dsize = msize
        this%cmb(i)%locked = .true.
        p => this%cmb(i)%data_d
        if (this%verbose) write(*, 103) i
        return  
      end if
      exit
    end do
    if (this%verbose) write(*, 104) 
    allocate(p(msize(1),msize(2)))
    info = -1
    !
    100 FORMAT ("Locking a buffer for an complex(DP), device matrix ", 2I4, " elements long")
    101 FORMAT ("Buffer ", I2 , " is free and ", 2I4, " elements long. Locked.")
    102 FORMAT ("Buffer ", I2 , " is free but ", 2I4, " elements long. Reallocating and Locking.")
    103 FORMAT ("Buffer ", I2 , " is free but not allocated. Allocated and Locked.")
    104 FORMAT ("No free buffers found. Allocated space outside buffers.")
  end subroutine lock_buffer_cm

  !> Get or allocate a buffer for an complex(DP), device tensor.
  subroutine lock_buffer_ct(this, p, tsize, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    complex(DP), device, pointer, intent(out) :: p(:,:,:)   !< Pointer possibly set to access buffer
    integer,       intent(in) :: tsize(3)    !< tensor dimension
    integer,       intent(out) :: info    !<  0: ok
                                          !< -1: no buffers left, allocating space
                                          !< -2: unexpected error, no memory left
                                          !< other values come form allocate stat
    integer :: i
    ! add omp critical here
    if (this%verbose) write(*,100) tsize
    info = 0
    ! the logic here is the following:
    !  we loop until a free (.i.e. not locked) buffer is found
    do i=1,this%nbufs
      !
      if (this%ctb(i)%locked) cycle
      ! if this point is reached, a free has been found
      !  check if it's large enough.
      if (ALL( this%ctb(i)%dsize >= tsize )) then
        this%ctb(i)%locked = .true.
        p => this%ctb(i)%data_d
        if (this%verbose) write(*,101) i , this%ctb(i)%dsize
        return
      else if (ALL( this%ctb(i)%dsize > 0 )) then
        if (this%verbose) write(*, 102) i, this%ctb(i)%dsize
        deallocate(this%ctb(i)%data_d)
        allocate(this%ctb(i)%data_d(tsize(1),tsize(2),tsize(3)), stat=info)
        if (info /= 0) return
        this%ctb(i)%dsize = tsize
        this%ctb(i)%locked = .true.
        p => this%ctb(i)%data_d
        return
      else
        ! the buffer was never initialized
        allocate(this%ctb(i)%data_d(tsize(1),tsize(2),tsize(3)), stat=info)
        if (info /= 0) return
        this%ctb(i)%dsize = tsize
        this%ctb(i)%locked = .true.
        p => this%ctb(i)%data_d
        if (this%verbose) write(*, 103) i
        return  
      end if
      exit
    end do
    if (this%verbose) write(*, 104) 
    allocate(p(tsize(1),tsize(2),tsize(3)))
    info = -1
    !
    100 FORMAT ("Locking a buffer for an complex(DP), device tensor ", 3I4, " elements long")
    101 FORMAT ("Buffer ", I2 , " is free and ", 3I4, " elements long. Locked.")
    102 FORMAT ("Buffer ", I2 , " is free but ", 3I4, " elements long. Reallocating and Locking.")
    103 FORMAT ("Buffer ", I2 , " is free but not allocated. Allocated and Locked.")
    104 FORMAT ("No free buffers found. Allocated space outside buffers.")
  end subroutine lock_buffer_ct

  !

  !> Release the buffer corresponding to pointer p, if associated with a buffer. Otherwise just deallocates.
  subroutine release_buffer_iv(this, p, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    integer, device, pointer, intent(inout) :: p(:)   !< Pointer possibly pointing to buffer space
    integer, intent(out)            :: info
    integer :: i
    ! add omp critical here
    info = 0
    do i=1,this%nbufs
      if (associated(p, this%ivb(i)%data_d)) then
        p=> NULL()
        this%ivb(i)%locked = .false.
        if (this%verbose) write(*,100) i
        return
      end if
    end do
    
    ! if this point is reached, the pointer was outside the buffers,
    !deallocate it
    info = -1
    if (associated(p)) then
      deallocate(p)
    else
      info = -2
      if (this%verbose) write(*,102) 
    end if
    p=>NULL()
    if (this%verbose) write(*,101) 
    100 FORMAT ("Pointer passed to release_buffer matched buffer ", I2,". Buffer released, pointer set to NULL.")
    101 FORMAT ("Pointer passed to release_buffer did not match any buffer! Data deallocated, pointer set to NULL.")
    102 FORMAT ("WARNING: Pointer passed to release_buffer is not associated! Pointer set to NULL.")
  end subroutine release_buffer_iv

  !> Release the buffer corresponding to pointer p, if associated with a buffer. Otherwise just deallocates.
  subroutine release_buffer_im(this, p, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    integer, device, pointer, intent(inout) :: p(:,:)   !< Pointer possibly pointing to buffer space
    integer, intent(out)            :: info
    integer :: i
    ! add omp critical here
    info = 0
    do i=1,this%nbufs
      if (associated(p, this%imb(i)%data_d)) then
        p=> NULL()
        this%imb(i)%locked = .false.
        if (this%verbose) write(*,100) i
        return
      end if
    end do
    
    ! if this point is reached, the pointer was outside the buffers,
    !deallocate it
    info = -1
    if (associated(p)) then
      deallocate(p)
    else
      info = -2
      if (this%verbose) write(*,102) 
    end if
    p=>NULL()
    if (this%verbose) write(*,101) 
    100 FORMAT ("Pointer passed to release_buffer matched buffer ", I2,". Buffer released, pointer set to NULL.")
    101 FORMAT ("Pointer passed to release_buffer did not match any buffer! Data deallocated, pointer set to NULL.")
    102 FORMAT ("WARNING: Pointer passed to release_buffer is not associated! Pointer set to NULL.")
  end subroutine release_buffer_im

  !> Release the buffer corresponding to pointer p, if associated with a buffer. Otherwise just deallocates.
  subroutine release_buffer_it(this, p, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    integer, device, pointer, intent(inout) :: p(:,:,:)   !< Pointer possibly pointing to buffer space
    integer, intent(out)            :: info
    integer :: i
    ! add omp critical here
    info = 0
    do i=1,this%nbufs
      if (associated(p, this%itb(i)%data_d)) then
        p=> NULL()
        this%itb(i)%locked = .false.
        if (this%verbose) write(*,100) i
        return
      end if
    end do
    
    ! if this point is reached, the pointer was outside the buffers,
    !deallocate it
    info = -1
    if (associated(p)) then
      deallocate(p)
    else
      info = -2
      if (this%verbose) write(*,102) 
    end if
    p=>NULL()
    if (this%verbose) write(*,101) 
    100 FORMAT ("Pointer passed to release_buffer matched buffer ", I2,". Buffer released, pointer set to NULL.")
    101 FORMAT ("Pointer passed to release_buffer did not match any buffer! Data deallocated, pointer set to NULL.")
    102 FORMAT ("WARNING: Pointer passed to release_buffer is not associated! Pointer set to NULL.")
  end subroutine release_buffer_it

  !> Release the buffer corresponding to pointer p, if associated with a buffer. Otherwise just deallocates.
  subroutine release_buffer_rv(this, p, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    real(DP), device, pointer, intent(inout) :: p(:)   !< Pointer possibly pointing to buffer space
    integer, intent(out)            :: info
    integer :: i
    ! add omp critical here
    info = 0
    do i=1,this%nbufs
      if (associated(p, this%rvb(i)%data_d)) then
        p=> NULL()
        this%rvb(i)%locked = .false.
        if (this%verbose) write(*,100) i
        return
      end if
    end do
    
    ! if this point is reached, the pointer was outside the buffers,
    !deallocate it
    info = -1
    if (associated(p)) then
      deallocate(p)
    else
      info = -2
      if (this%verbose) write(*,102) 
    end if
    p=>NULL()
    if (this%verbose) write(*,101) 
    100 FORMAT ("Pointer passed to release_buffer matched buffer ", I2,". Buffer released, pointer set to NULL.")
    101 FORMAT ("Pointer passed to release_buffer did not match any buffer! Data deallocated, pointer set to NULL.")
    102 FORMAT ("WARNING: Pointer passed to release_buffer is not associated! Pointer set to NULL.")
  end subroutine release_buffer_rv

  !> Release the buffer corresponding to pointer p, if associated with a buffer. Otherwise just deallocates.
  subroutine release_buffer_rm(this, p, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    real(DP), device, pointer, intent(inout) :: p(:,:)   !< Pointer possibly pointing to buffer space
    integer, intent(out)            :: info
    integer :: i
    ! add omp critical here
    info = 0
    do i=1,this%nbufs
      if (associated(p, this%rmb(i)%data_d)) then
        p=> NULL()
        this%rmb(i)%locked = .false.
        if (this%verbose) write(*,100) i
        return
      end if
    end do
    
    ! if this point is reached, the pointer was outside the buffers,
    !deallocate it
    info = -1
    if (associated(p)) then
      deallocate(p)
    else
      info = -2
      if (this%verbose) write(*,102) 
    end if
    p=>NULL()
    if (this%verbose) write(*,101) 
    100 FORMAT ("Pointer passed to release_buffer matched buffer ", I2,". Buffer released, pointer set to NULL.")
    101 FORMAT ("Pointer passed to release_buffer did not match any buffer! Data deallocated, pointer set to NULL.")
    102 FORMAT ("WARNING: Pointer passed to release_buffer is not associated! Pointer set to NULL.")
  end subroutine release_buffer_rm

  !> Release the buffer corresponding to pointer p, if associated with a buffer. Otherwise just deallocates.
  subroutine release_buffer_rt(this, p, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    real(DP), device, pointer, intent(inout) :: p(:,:,:)   !< Pointer possibly pointing to buffer space
    integer, intent(out)            :: info
    integer :: i
    ! add omp critical here
    info = 0
    do i=1,this%nbufs
      if (associated(p, this%rtb(i)%data_d)) then
        p=> NULL()
        this%rtb(i)%locked = .false.
        if (this%verbose) write(*,100) i
        return
      end if
    end do
    
    ! if this point is reached, the pointer was outside the buffers,
    !deallocate it
    info = -1
    if (associated(p)) then
      deallocate(p)
    else
      info = -2
      if (this%verbose) write(*,102) 
    end if
    p=>NULL()
    if (this%verbose) write(*,101) 
    100 FORMAT ("Pointer passed to release_buffer matched buffer ", I2,". Buffer released, pointer set to NULL.")
    101 FORMAT ("Pointer passed to release_buffer did not match any buffer! Data deallocated, pointer set to NULL.")
    102 FORMAT ("WARNING: Pointer passed to release_buffer is not associated! Pointer set to NULL.")
  end subroutine release_buffer_rt

  !> Release the buffer corresponding to pointer p, if associated with a buffer. Otherwise just deallocates.
  subroutine release_buffer_cv(this, p, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    complex(DP), device, pointer, intent(inout) :: p(:)   !< Pointer possibly pointing to buffer space
    integer, intent(out)            :: info
    integer :: i
    ! add omp critical here
    info = 0
    do i=1,this%nbufs
      if (associated(p, this%cvb(i)%data_d)) then
        p=> NULL()
        this%cvb(i)%locked = .false.
        if (this%verbose) write(*,100) i
        return
      end if
    end do
    
    ! if this point is reached, the pointer was outside the buffers,
    !deallocate it
    info = -1
    if (associated(p)) then
      deallocate(p)
    else
      info = -2
      if (this%verbose) write(*,102) 
    end if
    p=>NULL()
    if (this%verbose) write(*,101) 
    100 FORMAT ("Pointer passed to release_buffer matched buffer ", I2,". Buffer released, pointer set to NULL.")
    101 FORMAT ("Pointer passed to release_buffer did not match any buffer! Data deallocated, pointer set to NULL.")
    102 FORMAT ("WARNING: Pointer passed to release_buffer is not associated! Pointer set to NULL.")
  end subroutine release_buffer_cv

  !> Release the buffer corresponding to pointer p, if associated with a buffer. Otherwise just deallocates.
  subroutine release_buffer_cm(this, p, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    complex(DP), device, pointer, intent(inout) :: p(:,:)   !< Pointer possibly pointing to buffer space
    integer, intent(out)            :: info
    integer :: i
    ! add omp critical here
    info = 0
    do i=1,this%nbufs
      if (associated(p, this%cmb(i)%data_d)) then
        p=> NULL()
        this%cmb(i)%locked = .false.
        if (this%verbose) write(*,100) i
        return
      end if
    end do
    
    ! if this point is reached, the pointer was outside the buffers,
    !deallocate it
    info = -1
    if (associated(p)) then
      deallocate(p)
    else
      info = -2
      if (this%verbose) write(*,102) 
    end if
    p=>NULL()
    if (this%verbose) write(*,101) 
    100 FORMAT ("Pointer passed to release_buffer matched buffer ", I2,". Buffer released, pointer set to NULL.")
    101 FORMAT ("Pointer passed to release_buffer did not match any buffer! Data deallocated, pointer set to NULL.")
    102 FORMAT ("WARNING: Pointer passed to release_buffer is not associated! Pointer set to NULL.")
  end subroutine release_buffer_cm

  !> Release the buffer corresponding to pointer p, if associated with a buffer. Otherwise just deallocates.
  subroutine release_buffer_ct(this, p, info)
    use cudafor
    implicit none
    class(buf_t), intent(inout)  :: this     !< The class.
    complex(DP), device, pointer, intent(inout) :: p(:,:,:)   !< Pointer possibly pointing to buffer space
    integer, intent(out)            :: info
    integer :: i
    ! add omp critical here
    info = 0
    do i=1,this%nbufs
      if (associated(p, this%ctb(i)%data_d)) then
        p=> NULL()
        this%ctb(i)%locked = .false.
        if (this%verbose) write(*,100) i
        return
      end if
    end do
    
    ! if this point is reached, the pointer was outside the buffers,
    !deallocate it
    info = -1
    if (associated(p)) then
      deallocate(p)
    else
      info = -2
      if (this%verbose) write(*,102) 
    end if
    p=>NULL()
    if (this%verbose) write(*,101) 
    100 FORMAT ("Pointer passed to release_buffer matched buffer ", I2,". Buffer released, pointer set to NULL.")
    101 FORMAT ("Pointer passed to release_buffer did not match any buffer! Data deallocated, pointer set to NULL.")
    102 FORMAT ("WARNING: Pointer passed to release_buffer is not associated! Pointer set to NULL.")
  end subroutine release_buffer_ct


#endif
end module
